Frequenty Asked Questions:

*Contents
1.  What is slapt-get ?
2.  Why yet another package management tool for slackware?
3.  How do I build/install slapt-get?  How do I remove slapt-get?
4.  How do I find a package I want to install?
5.  Can I upgrade all my installed packages?
6.  How can I see what will be upgraded without upgrading?
7.  What if I only want to download the updates?
8.  How can I re-install an existing package?
9.  Can I "dist-upgrade" to a newer Slackware release?
10. What about package dependencies?
11. What about multiple package sources, ala linuxpackages.net?
12. I don't like the download spinner, how can I get more statistics?
13. How can I install every available package?
14. What if I only want to upgrade one package?
15. What about Dropline support?
16. How can I generate an exclude list for an entire disk set?
17. How do I use a local file source?
18. How can I download every package in a disk set?
19. How can I add dependency information to my packages?
22. How do I get the newest development version of slapt-get?
23. How can I contribute my ideas or code?
24. How can I get slapt-get to speak in my native tongue?
25. How do I set the output language?
26. How do I specify proxy settings?
27. How can I exclude all *pre*, *beta*, and *686* packages safely?
28. How does the transaction engine work?
29. How does the package version comparison algorithm work?
30. I am tracking current, how do I keep the base disk set up to date?
31. How would I script an ldd dependency hack with slapt-get?
32. Does EXCLUDE work for install as well as upgrade and dist-upgrade?
33. What about package conflicts?  How can I specify a conflict for my package?
34. Is the ROOT environment variable honored for install and upgrading?



1.  What is slapt-get ?

 slapt-get is an APT like system for Slackware package management. It allows
 one to search slackware.com and mirrors for packages, compare them with
 installed packages, install new packages or upgrade installed packages all
 with a few simple commands. Great for scripting as well.


2.  Why yet another package management tool for slackware?

 To scratch and itch of mine, which also scratched an itch of a friend.  I
 created it originally without looking for an existing solution.  I now
 understand Slackware already has existing utilities that provide similar
 functionality.  I believe slapt-get to be superior because of it's speed and
 simplicity.  I do not believe slapt-get takes away anything from these
 existing tools, slapt-get can stand on it's own merits.  In the end, choice
 is great for the end users (just as in the desktop enviroment category).  
 Regardless, I do not aim for inclusion within Slackware.  I only want to make
 this availabe in hopes that others will find it useful.
 

3.  How do I build/install slapt-get?  How do I remove slapt-get?

 Two ways to install:

  A: You can build slapt-get from source and use the 'install' make target,
 
  B: You can build from source and make a Slackware package with the 'pkg'
     make target.  Then install the generated package within the newly created
     'pkg' directory.

 If you installed via `make install`, there is an 'uninstall' make target.

 If you installed the slack package, then use removepkg.


4.  How do I find a package I want to install?

 You can use the --search feature, supplying an expression.  POSIX 
 and extended regular expressions are supported.  This searches the name,
 location, or descriptions of packages.


5.  Can I upgrade all my installed packages?

 Yes, use the --upgrade option.  slapt-get will check for 
 newer versions of all packages already installed.


6.  How can I see what will be upgraded without upgrading?

 If the transaction report is not enough, use the --simulate option before
 --upgrade.  See slapt-get --help


7.  What if I only want to download the updates?

 Use the --download-only option before --upgrade.
 See slapt-get --help


8.  How can I re-install an existing package?

 Use the --reinstall option with --install pkg_name.
 See slapt-get --help


9.  Can I "dist-upgrade" to a newer Slackware release?

 Yes.

 Change your source location within /etc/slapt-getrc to point to the newer
 release directory.  --update your local package cache, then --dist-upgrade
 to the newer release.  You will also want to disable any third party package
 sources while upgrading to a newer release so you do not mix and match
 packages.

 For instance, you have the following uncommented line as your source:

   SOURCE=ftp://distro.ibiblio.org/pub/Linux/distributions/slackware/slackware-9.0/

 Simply change the url to point to current, like so:

   SOURCE=ftp://distro.ibiblio.org/pub/Linux/distributions/slackware/slackware-current/

 CAVEAT: The simplicity of slapt-get means a lot of assurances are not in
         place.  You can break a working system if you do not follow the
         suggestions in UPGRADE.TXT.

 Now you --dist-upgrade to retrieve the package data for that release.
 What dist-upgrade does is basically make sure that any missing packages
 from the base disk set are installed, as well as upgrade to any newer
 versions of the currently installed packages.  All of this happens in
 one transaction.

 dist-upgrade'ing involves doing the following:

   ### upgrade your local package cache
   $ slapt-get --update

   ### first, upgrade the most important
   #(this installs any newer versions)
   $ slapt-get --install glibc-solibs pkgtools sed

   ### then, let slapt-get upgrade the rest
   $ slapt-get --dist-upgrade

 Then follow the rest of the directions in UPGRADE.TXT.

   * Note: you might be able to get away with just doing a --dist-upgrade after
     the --update.  The second step above is made as a suggestion to follow
     the suggestions and conventions in UPGRADE.TXT.


10.  What about package dependencies?

 Other tools try to provide dependency checking via various hacks (generating
 the dependency file, exploding the package, then ldd'ing binary files to find
 missing libraries before consulting the dependency file).  This is not a
 reliable/fool proof method.  It is also extremeley slow.  Dependencies can not
 always be defined strictly by library dependencies.  Applications, rather than
 libraries may be required, such as the case with man and groff.

 I believe that package dependency support can be implemented in a Slackware 
 compatible way.  If we look to the existing infrastructure Pat has created
 for inspiration, we come to the simple addition of another file within the
 packages ./install directory.  Let's call it slack-required.  This information
 could be as simple as what rules existed in the autoconf scripts of the 
 upstream source.

 This file has a simple structure.  See FAQ # 19 for an example on the
 structure of an example slack-required file.

 slapt-get can resolve dependencies via the slack-required meta data.  Already
 there are packages being submitting to linuxpackages.net supporting this
 optional metadata.

 I have made sure that this information does not impact the ability of packages
 to be installed by the existing Slackware package tools.  This information
 now simply becomes an additional extension, easily bypassed or simply ignored.

 The information within slack-required can be added to the PACKAGES.TXT file.
 Scripts that generate mindful PACKAGES.TXT files are available, such as the
 one in this FAQ, see #17.

 So the package's entry within PACKAGES.TXT would go from:

   PACKAGE NAME:  man-1.5l-i386-1.tgz
   PACKAGE LOCATION:  ./slackware/ap
   PACKAGE SIZE (compressed):  166 K
   PACKAGE SIZE (uncompressed):  390 K
   PACKAGE DESCRIPTION:
   man: man (format and display the on-line manual pages)

 to this (note only an additional line per package entry):

   PACKAGE NAME:  man-1.5l-i386-1.tgz
   PACKAGE LOCATION:  ./slackware/ap
   PACKAGE SIZE (compressed):  166 K
   PACKAGE SIZE (uncompressed):  390 K
   PACKAGE REQUIRES: groff,man-pages
   PACKAGE DESCRIPTION:
   man: man (format and display the on-line manual pages)

 Since dependency information is known when the package is created, that is
 the best time/place to make that data available.  It is a simple progression
 from making a note within the package description such as the one already
 within the man package:

   man: man (format and display the on-line manual pages)
   man:
   man: The man package is a collection of tools used for searching and
   man: reading the online system documentation.  In fact, on most UNIX-like
   man: operating systems it is the primary means of finding out how programs
   man: on the system work.  For example, 'man man' will display the
   man: documentation for man itself.
   man:
   man: *-->*Man requires the groff text processing package.*<--*
   man:

 to providing that data in a way that can be scripted for those who have
 the advanced knowledge or want to provide higher level tools for Slackware.

 I hope if the community as a whole agrees that this is an added benefit 
 (without becoming overly complex or kludgey) they can convince Pat there is
 a need/demand for it.



11. What about multiple package sources, ala linuxpackages.net?

 You can use multiple sources with slapt-get (including linuxpackages.net).
 See the example slapt-getrc in the source tarball, or look in
 /etc/slapt-getrc.new if you installed via slackpack. See also README.


12. I don't like the download spinner, how can I get more statistics?

 If you would like more notification on downloading pkgs/files, change the 
 USE_CURL_PROGRESS macro to 1 in include/curl.h.  This turns on curl's
 internal progress meter.  This requires a recompile.


13. How can I install every available package?

 Even though it's not built in, it's simple since slapt-get is easy to script
 with.  Here is a simple shell script to install every package that is
 available but not currently installed:

   #!/bin/sh
   # Dan Barber <danb at mojolin dot com>
   slapt-get --update
   slapt-get --installed > /tmp/slapt_get_installed
   for file in `slapt-get --list | cut -f1 -d" " | sort`
     do
     echo -n "$file "
     if [ -z "`grep "\W+$file\W+" /tmp/slapt_get_installed`" ]; then
       if [ -z "`grep '\W+$file\W?' /etc/slapt-getrc`" ]; then
         echo "excluded"
       else
         echo "not installed"
         slapt-get --install $file
       fi
     fi
   done



14. What if I only want to upgrade one package?

 Then you follow the debian apt-get method of using --install.
 If the package is already installed, it will check and install any newer
 versions:

 slapt-get --install {pkg_name}


15. What about Dropline support?

 There is no direct support for dropline packages.  If you do not want them
 upgraded, either put the package names or regex into the exception list or
 use interactive mode (do not use --no-prompt, use --interactive).

 You can use the following for a dropline exclude (from example slapt-getrc):
 
  EXCLUDE=kernel-ide,kernel-source,kernel-headers,kernel-modules,lilo,.*-[0-9]dl$,devs


16. How can I generate an exclude list for an entire disk set?

 You can use this script to generate a listing of packages to add to your
 exlude list:

   #!/bin/sh
   # this should gen an exclude list for a particular dir set (first arg to script)
   DIR=$1
   slapt-get --search "^\.\/slackware\/${DIR}$"|awk '{print $1}'|\
    xargs -iZ echo -n "Z,"|sed -e 's/,$//'


17. How do I use a local file source?

 Within slapt-getrc, change your SOURCE= lines to point to file:// url's.

 For example, you could have an official and a local source like:
 SOURCE=ftp://ftp.slackware.no/pub/linux/slackware/slackware-9.1/
 SOURCE=file:///usr/src/local_pkg_repository/

 This local directory must have the PACKAGES.TXT and CHECKSUMS.md5 files
 present.  This could be a mounted Slackware release CDROM, or a custom
 repository.

 The CHECKSUMS.md5 file can be generated with find:
  rm CHECKSUMS.md5; find . -name '*.tgz' -exec md5sum {} >> CHECKSUMS.MD5 \;

 The PACKAGES.TXT can be generated by the following script:

 ### BEGIN SCRIPT
    #!/bin/sh

    function gen_packages_txt {
	    echo '' > PACKAGES.TXT
	    find . -type f -name '*.meta' -exec cat {} \; >> PACKAGES.TXT
    }

    function gen_md5_checksums {
	    echo '' > CHECKSUMS.md5
	    find . -type f -name '*.tgz' -exec md5sum {} \; >> CHECKSUMS.md5
    }

    function gen_meta {
	    if [ ! -f $1 ]; then
		    echo "File not found: $1"
		    exit 1;
	    fi
			if [ "`echo $1|grep -E '(.*{1,})\-(.*[\.\-].*[\.\-].*).tgz[ ]{0,}$'`" == "" ]; then
				return;
			fi
	    NAME=$(echo $1|sed -re "s/(.*\/)(.*.tgz)$/\2/")
	    LOCATION=$(echo $1|sed -re "s/(.*)\/(.*.tgz)$/\1/")
	    SIZE=$( expr `gunzip -l $1 |tail -1|awk '{print $1}'` / 1024 )
	    USIZE=$( expr `gunzip -l $1 |tail -1|awk '{print $2}'` / 1024 )
	    REQUIRED=$(tar xzf $1 install/slack-required -O 2>/dev/null|xargs -r -iZ echo -n "Z,"|sed -e "s/,$//")
	    CONFLICTS=$(tar xzf $1 install/slack-conflicts -O 2>/dev/null|xargs -r -iZ echo -n "Z,"|sed -e "s/,$//")
	    METAFILE=$(echo $NAME|sed -re "s/\.tgz$/\.meta/")
	    echo "PACKAGE NAME:  $NAME" > $LOCATION/$METAFILE
	    echo "PACKAGE LOCATION:  $LOCATION" >> $LOCATION/$METAFILE
	    echo "PACKAGE SIZE (compressed):  $SIZE K" >> $LOCATION/$METAFILE
	    echo "PACKAGE SIZE (uncompressed):  $USIZE K" >> $LOCATION/$METAFILE
	    echo "PACKAGE REQUIRED:  $REQUIRED" >> $LOCATION/$METAFILE
	    echo "PACKAGE CONFLICTS:  $CONFLICTS" >> $LOCATION/$METAFILE
	    echo "PACKAGE DESCRIPTION:" >> $LOCATION/$METAFILE
	    tar xzf $1 install/slack-desc -O|grep -E '\w+\:'|grep -v '^#' >> $LOCATION/$METAFILE
	    echo "" >> $LOCATION/$METAFILE
    }

    case "$1" in
	    pkg)
		    if [ -n "$2" ]; then
			    gen_meta $2
		    else
			    echo "$0 [pkg [file]|all|new|PACKAGESTXT|MD5]"
		    fi
	    ;;
	    all)
		    for pkg in `find . -type f -name '*.tgz' -print`
		    do
			    gen_meta $pkg
		    done
		    $0 PACKAGESTXT
		    $0 MD5
	    ;;
	    new)
		    for pkg in `find . -type f -name '*.tgz' -print`
		    do
			    if [ ! -f "`echo $pkg|sed -re 's/\.tgz$/\.meta/'`" ]; then
				    gen_meta $pkg
			    fi
		    done
	    ;;
	    PACKAGESTXT)
		    gen_packages_txt
	    ;;
	    MD5)
		    gen_md5_checksums
	    ;;
	    *)
		    echo "$0 [pkg [file]|all|PACKAGESTXT|MD5]"
	    ;;
    esac
 ### END SCRIPT


18. How can I download every package in a disk set?

 You can search the package location field, which specifies which directory
 the package resides in, on the mirror.

 Most mirrors use ./slackware/{disk set} as the directory for the set.  Thus
 to install every package from xap:

   slapt-get --search '^\.\/slackware\/xap$'|awk '{print $1}'| \
     xargs -r slapt-get --install


19. How can I add dependency information to my packages?

 This is for package developers.  If you are not a package developer, please
 request your packager include this information.

 To export the dependency data for a package, include within your package the
 following file:

   ./install/slack-required

 The structure of this file is one entry per line in the following format:

    package_name

 or
    [package_name] [condition] [version]

 where [condition] is

    =, >=, =<, <, or >

 <= and =< should both work, just in case of editing errors.

 Version should include the arch and build if using '='.  That is the full
 slackware package version designation.  1.1.0-386-1 is valid.  1.1.0 is not.

 The package names are case sensitive.  So make sure you keep the case of the
 package name as it appears in the package filename.

 An example slack-required file is present within the slapt-get slack package.

 This data will then need to be extracted when the mirror's PACKAGES.TXT file
 is generated.  See FAQ #17 for an example of how to generate the
 PACKAGES.TXT file.  The following is an example entry:

    PACKAGE NAME:  man-pages-1.56-noarch-1.tgz
    ...(snip)
    PACKAGE REQUIRED:  man >= 1.5l-i386-1

 An example command to pull that data:
   tar xzf pkg-name-version-arch-rel.tgz install/slack-required -O|xargs -iZ echo -n "Z,"|sed -e "s/,$//"


20. How do I get the newest development version of slapt-get?

 See the 'Using cvs' section of the INSTALL document.


23. How can I contribute my ideas or code?

 Send in ideas or patches to the development list:

   slapt-get-devel at software dot jaos dot org

 The user list can be used for questions on slapt-get usage, etc:

   slapt-get-user at software dot jaos dot org


24. How can I get slapt-get to speak in my native tongue?

 Translations are needed.  GNU gettext is used to extract all translatable strings
 from the source.  Please look in the po/ directory of the slapt-get source, or in
 /usr/share/slapt-get/locales.  Copy the slapt-get.pot file to a new files named
 with your native language abbreviation, ending in .po.  For example, to 
 translate to German,

 $ cp /usr/share/slapt-get/locales/slapt-get.pot /tmp/de.po

 Edit that file.  For every msgid, translate that into the msgstr "".  Leave the
 formatting the same.

 So if your language is German, 

 $ cp slapt-get.pot de.po

 Email in your translation to the slapt-get-devel mailing list.  Your contributions
 are greatly appreciated.


25. How do I set the output language?

 You can change the locale at runtime by setting the LANG environment
 variable.

 $ LANG=fr slapt-get


26. How do I specify proxy settings?

 slapt-get takes advantage of the normal http_proxy and ftp_proxy shell
 variables. Here are some examples:

  # setting the env variables for the entire session
  $ export http_proxy=http://host:port
  $ export ftp_proxy=ftp://host:port
  # just setting them for the current command invocation
  $ http_proxy=http://host:port slapt-get --update


27. How can I exclude all *pre*, *beta*, and *686* packages safely?

 An exclude regex like .*pre.* , .*beta.*, or .*686.* may net you the results
 of excluding all packages with those characters in the name or version.  But
 they may also catch packages that have those characters normally occuring in
 the package name.

 This regex seems to work much better:

   [0-9\_\.\-]{1}pre[0-9\-\.\-]{1}

 for beta packages:

   [0-9\_\.\-]{1}beta[0-9\-\.\-]{1}

 or for i686 packages (or for i585 or i486):

   [0-9\_\.\-]+i686

 Anything matching these regex will be added to the exclude list for the
 transaction.


28. How does the transaction engine work?

 The last few series of releases (0.9.6x and 0.9.7x) have supported
 transactions so that nothing happens unless everything checks out properly.
 The transaction is built up of packages to install, upgrade and remove.	The
 transaction status will be reported to the user to be confirmed (unless the
 user passes in --no-prompt on the command line).  After this confirmation, all
 packages will be downloaded before anything else happens.  If anything fails
 to download, the transaction is immediately aborted.	If all pacakges download
 successfully, all packages to be installed (new installs) are installed first.
 This should satisfy dependencies of the packages to be upgraded, which follow
 after the new installs.  Finally, and removals in the transaction are
 completed.  This helps keep your system in a consistant state, and should give
 you full control.


29. How does the package version comparison algorithm work?

 Say we have foo-1.1.3-i386-1rob and foo-1.1.3-i686-1.

 The version parts will be compared, first 1, then 1, then 3.  At this point,
 both packages are equal, since 1.1.3 == 1.1.3. If one is greater at this
 point, the version check returns.

 Then it checks to make sure that both pkgs have the same number of "version
 parts".  This is the case in this example, both have 3 (1,1,3).	This is useful
 when you see packages like 1.2 and 1.2.1. Whichever has more parts wins.  At
 this point, we know if one only has 2 parts, and the other has 3, then the
 first two parts of both version strings have to be equal.

 Then the package versions are checked to see if they follow the slackware
 convention.  This is determined by checking the first instance of '-' against
 the last instance.  If the pointer returned from index and rindex are
 different, then we assume we have at least two package version separators
 (meaning we should have an upstream version, arch, and build at least).

 If two separators are found, the build portion of the string is located.  The
 integer value of the build strings are compared.  So "1rob" has an integer
 value of 1, and "1" has an integer value of 1.  So in our example, both package
 versions are the same.

 If the only difference is the arch and the packages follow the conventions,
 then they should always be equal.

 If two separators are not found, then the entire version string from both pkgs
 are compared via strcmp.  This is a fallback mechanism.


30. I am tracking current, how do I keep the base disk set up to date?

 If you are tracking current, --dist-upgrade may be more useful than --upgrade.

 Even if you aren't intentionally switching to a newer distribution,
 --dist-upgrade will ensure that the base set is always present while at the
 same time keeping your installed packages up to date.


31. How would I script an ldd dependency hack with slapt-get?

 Do something like the following:

 ### begin script
 #!/bin/sh
 # slapt-get wrapper to hack dependencies via ldd where slack-required isn't available
 # Copyright (C) 11-30-2003 Jason Woodward <woodwardj at jaos dot org>
 WORKINGDIR=`grep WORKINGDIR /etc/slapt-getrc|cut -f2 -d'='`
 MF=MANIFEST
 PKGLINES=${WORKINGDIR}/depslapt_pkgs
 DEPDATA=()
 DEPDATACOUNT=0
 
 function get_pkg_cache_data {
 	if [ -f ${MF} ]; then rm ${MF};fi
 	for url in `grep '^SOURCE' /etc/slapt-getrc|cut -f2 -d'='`
 	do
 		echo "retrieving data from $url"
 		if [ -f ${MF}.bz2 ]; then rm ${MF}.bz2;fi
 		wget -q ${url}/${MF}.bz2
 		if [ -f ${MF}.bz2 ]; then
 			bunzip2 -c ${MF}.bz2 >> ${MF}; rm ${MF}.bz2
 		else
 			wget -q ${url}/slackware/${MF}.bz2
 			if [ -f ${MF}.bz3 ]; then bunzip2 -c ${MF}.bz2 >> ${MF}; rm ${MF}.bz2; fi
 		fi
 	done
 	echo "extracting package data"
 	grep -n ' Package\: ' ${MF}|awk '{print $1 $3}'|sed -re "s/\|//g" > ${PKGLINES}
 }
 
 function map_to_pkg {
 	LOOKUP=$1
 	LASTPKG=
 	for pkgline in `cat ${PKGLINES}|cut -f1 -d':'`
 	do
 		if [ $LOOKUP -gt $pkgline ]; then
 			false
 		else
 			LASTPKG=`grep -B 1 $pkgline ${PKGLINES} |head -1|cut -f2 -d':'`
 			return
 		fi
 	done
 	### clear it in case we get here
 	LASTPKG=
 }
 
 function lookup_lib {
 	for linenumber in `grep -n $1 /var/slapt-get/${MF}|cut -f1 -d':'`
 	do
 		map_to_pkg $linenumber
 		if [ -n "$LASTPKG" ]; then
 			DEPS[$DEPCOUNT]=`basename $LASTPKG|sed -re "s/(.*{1,})\\-(.*[\\.\\-].*[\\.\\-].*).tgz[ ]{0,}$/\1/"`
 			DEPCOUNT=$((DEPCOUNT + 1))
 		fi
 	done
 }
 
 function resolve_dependencies {
 	DEPS=()
 	DEPCOUNT=0
 	for pkg in "$@"
 	do
 		INST=`ls /var/log/packages/|grep ${pkg}|sort -rn|head -1`
 		FILES="`cat /var/log/packages/$INST|grep 'bin\/'|grep -v '\/$'`"
 		for file in $FILES
 		do
 			MISSINGLIBS=`ldd /${file}|grep -i 'not found'|awk '{print $1}'|sort|uniq`
 			for lib in $MISSINGLIBS
 			do
 				echo "Missing lib: $lib"
 				lookup_lib $lib
 			done
 		done
 	done
 	### recurse
 	if [ $DEPCOUNT -gt 0 ]; then
 		slapt-get --install ${DEPS[*]} || exit
 		resolve_dependencies ${DEPS[*]}
 	fi
 }
 
 # give usage if no arguments
 if [ -z "$1" ]; then echo "Usage: $0 [--update|packages]"; exit; fi
 # get package cache data if it's not already there, or we want it
 cd ${WORKINGDIR}
 if [ "$1" == "--update" ]; then shift; get_pkg_cache_data; fi
 if [ ! -f ${PKGLINES} ]; then get_pkg_cache_data; fi
 # read pkg data into memory 
 while read line;do DEPDATA[${DEPDATACOUNT}]=$line; DEPDATACOUNT=$((DEPDATACOUNT + 1)); done < ${PKGLINES}
 # install with slapt-get, then call the resolve_dependencies
 slapt-get $SLAPT_OPTS --install "$@" || exit
 resolve_dependencies $@
 ### end script


32. Does EXCLUDE work for install as well as upgrade and dist-upgrade?

 No, EXCLUDE is only consulted for upgrading and dist-upgrading.  If you
 specify the package name as an argument to --install, slapt-get will 
 ignore the EXCLUDE list.


33. What about package conflicts?  How can I specify a conflict for my package?

 Package conflicts are not as common as dependencies, but just as crucial.
 Packages such as lprng and cups sometimes duplicate the same functionality.

 To address this, include within your package ./install/slack-conflicts.  This
 file has the same syntax as the slack-required file.  

 The following is a fictitious example of a lprng slack-conflicts file:

 # cat ./install/slack-conflicts
   gnome-cups-manager <= 0.16
   libgnomecups <= 0.1.5
   cups
 #

 In this example, we want to specify that the gnome-cups-manager and
 libgnomecups packages are in conflict if they are below a certain version,
 (supposing that the older versions do not support lprng).  The third entry,
 cups, is a direct conflict, without any compatible version.


34. Is the ROOT environment variable honored for install and upgrading?

 Yes, if you have been using ROOT with installpkg and upgradepkg, slapt-get
 will modify where it looks for the package logs based on this environment
 variable.



